/*!
 * Copyright 2016 Google Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/// <reference types="node" />
import { ExistsCallback, GetConfig } from '@google-cloud/common';
import { GrpcServiceObject } from './common-grpc/service-object';
import * as r from 'teeny-request';
import { Operation as GaxOperation } from 'google-gax';
import { BatchTransaction, TransactionIdentifier } from './batch-transaction';
import { google as databaseAdmin } from '../proto/spanner_database_admin';
import { Instance } from './instance';
import { PartialResultStream, Row } from './partial-result-stream';
import { Session } from './session';
import { SessionPoolOptions, SessionPoolCloseCallback, SessionPoolInterface } from './session-pool';
import { Table, CreateTableCallback, CreateTableResponse } from './table';
import { Snapshot, TimestampBounds, Transaction, ExecuteSqlRequest, RunUpdateCallback, RunResponse } from './transaction';
import { AsyncRunTransactionCallback, RunTransactionCallback, RunTransactionOptions } from './transaction-runner';
import { google } from '../proto/spanner';
import { Schema, RequestCallback, PagedRequest, ResourceCallback, PagedResponse, NormalCallback } from './common';
import { Readable, Duplex } from 'stream';
import { google as spannerClient } from '../proto/spanner';
import { RequestConfig } from '.';
declare type CreateBatchTransactionCallback = ResourceCallback<BatchTransaction, google.spanner.v1.ITransaction | google.spanner.v1.ISession>;
declare type CreateBatchTransactionResponse = [BatchTransaction, google.spanner.v1.ITransaction | google.spanner.v1.ISession];
declare type DatabaseResponse = [Database, r.Response];
declare type DatabaseCallback = ResourceCallback<Database, r.Response>;
declare type GetSnapshotCallback = NormalCallback<Snapshot>;
declare type GetTransactionCallback = NormalCallback<Transaction>;
export interface SessionPoolConstructor {
    new (database: Database, options?: SessionPoolOptions | null): SessionPoolInterface;
}
export declare type UpdateSchemaCallback = ResourceCallback<GaxOperation, databaseAdmin.longrunning.IOperation>;
export declare type UpdateSchemaResponse = [GaxOperation, databaseAdmin.longrunning.IOperation];
declare type PoolRequestCallback = RequestCallback<Session>;
declare type RunCallback = RequestCallback<Row[]>;
declare type GetSessionsOptions = PagedRequest<google.spanner.v1.IListSessionsRequest>;
declare type GetMetadataResponse = [databaseAdmin.spanner.admin.database.v1.IDatabase];
declare type GetMetadataCallback = RequestCallback<databaseAdmin.spanner.admin.database.v1.IDatabase>;
declare type GetSchemaCallback = RequestCallback<string, databaseAdmin.spanner.admin.database.v1.IGetDatabaseDdlResponse>;
declare type GetSchemaResponse = [string[], databaseAdmin.spanner.admin.database.v1.IGetDatabaseDdlResponse];
declare type GetSessionsCallback = RequestCallback<Session, google.spanner.v1.IListSessionsResponse>;
declare type GetSessionsResponse = PagedResponse<Session, google.spanner.v1.IListSessionsResponse>;
export declare type GetDatabaseConfig = GetConfig & databaseAdmin.spanner.admin.database.v1.GetDatabaseRequest;
declare type DatabaseCloseResponse = [google.protobuf.IEmpty];
export declare type CreateSessionResponse = [Session, spannerClient.spanner.v1.ISession];
export interface CreateSessionOptions {
    name?: string | null;
    labels?: {
        [k: string]: string;
    } | null;
}
export declare type CreateSessionCallback = ResourceCallback<Session, spannerClient.spanner.v1.ISession>;
export interface BatchCreateSessionsOptions extends CreateSessionOptions {
    count: number;
}
export declare type BatchCreateSessionsResponse = [Session[], spannerClient.spanner.v1.IBatchCreateSessionsResponse];
export declare type BatchCreateSessionsCallback = ResourceCallback<Session[], spannerClient.spanner.v1.IBatchCreateSessionsResponse>;
export declare type DatabaseDeleteCallback = NormalCallback<r.Response>;
export interface CancelableDuplex extends Duplex {
    cancel(): void;
}
/**
 * Create a Database object to interact with a Cloud Spanner database.
 *
 * @class
 *
 * @param {string} name Name of the database.
 * @param {SessionPoolOptions|SessionPoolInterface} options Session pool
 *     configuration options or custom pool interface.
 * @param {spannerClient.spanner.v1.ExecuteSqlRequest.IQueryOptions} queryOptions
 *     The default query options to use for queries on the database.
 *
 * @example
 * const {Spanner} = require('@google-cloud/spanner');
 * const spanner = new Spanner();
 * const instance = spanner.instance('my-instance');
 * const database = instance.database('my-database');
 */
declare class Database extends GrpcServiceObject {
    formattedName_: string;
    pool_: SessionPoolInterface;
    queryOptions_?: spannerClient.spanner.v1.ExecuteSqlRequest.IQueryOptions;
    request: <T, R = void>(config: RequestConfig, callback: RequestCallback<T, R>) => void;
    constructor(instance: Instance, name: string, poolOptions?: SessionPoolConstructor | SessionPoolOptions, queryOptions?: spannerClient.spanner.v1.ExecuteSqlRequest.IQueryOptions);
    static getEnvironmentQueryOptions(): google.spanner.v1.ExecuteSqlRequest.IQueryOptions;
    batchCreateSessions(options: number | BatchCreateSessionsOptions): Promise<BatchCreateSessionsResponse>;
    batchCreateSessions(options: number | BatchCreateSessionsOptions, callback: BatchCreateSessionsCallback): void;
    /**
     * Get a reference to a {@link BatchTransaction} object.
     *
     * @see {@link BatchTransaction#identifier} to generate an identifier.
     *
     * @param {TransactionIdentifier} identifier The transaction identifier.
     * @param {TransactionOptions} [options] [Transaction options](https://cloud.google.com/spanner/docs/timestamp-bounds).
     * @returns {BatchTransaction} A batch transaction object.
     *
     * @example
     * const {Spanner} = require('@google-cloud/spanner');
     * const spanner = new Spanner();
     *
     * const instance = spanner.instance('my-instance');
     * const database = instance.database('my-database');
     *
     * const transaction = database.batchTransaction({
     *   session: 'my-session',
     *   transaction: 'my-transaction',
     *   readTimestamp: 1518464696657
     * });
     */
    batchTransaction(identifier: TransactionIdentifier, options?: TimestampBounds): BatchTransaction;
    close(callback: SessionPoolCloseCallback): void;
    close(): Promise<DatabaseCloseResponse>;
    createBatchTransaction(options?: TimestampBounds): Promise<CreateBatchTransactionResponse>;
    createBatchTransaction(callback: CreateBatchTransactionCallback): void;
    createBatchTransaction(options: TimestampBounds, callback: CreateBatchTransactionCallback): void;
    createSession(options: CreateSessionOptions): Promise<CreateSessionResponse>;
    createSession(callback: CreateSessionCallback): void;
    createSession(options: CreateSessionOptions, callback: CreateSessionCallback): void;
    createTable(schema: Schema): Promise<CreateTableResponse>;
    createTable(schema: Schema, callback?: CreateTableCallback): void;
    /**
     * Decorates transaction so that when end() is called it will return the session
     * back into the pool.
     *
     * @private
     *
     * @param {Session} session The session to release.
     * @param {Transaction} transaction The transaction to observe.
     * @returns {Transaction}
     */
    private _releaseOnEnd;
    delete(): Promise<[r.Response]>;
    delete(callback: DatabaseDeleteCallback): void;
    exists(): Promise<[boolean]>;
    exists(callback: ExistsCallback): void;
    get(options?: GetDatabaseConfig): Promise<DatabaseResponse>;
    get(callback: DatabaseCallback): void;
    get(options: GetDatabaseConfig, callback: DatabaseCallback): void;
    getMetadata(): Promise<GetMetadataResponse>;
    getMetadata(callback: GetMetadataCallback): void;
    getSchema(): Promise<GetSchemaResponse>;
    getSchema(callback: GetSchemaCallback): void;
    getSessions(options?: GetSessionsOptions): Promise<GetSessionsResponse>;
    getSessions(callback: GetSessionsCallback): void;
    getSessions(options: GetSessionsOptions, callback: GetSessionsCallback): void;
    getSnapshot(options?: TimestampBounds): Promise<[Snapshot]>;
    getSnapshot(callback: GetSnapshotCallback): void;
    getSnapshot(options: TimestampBounds, callback: GetSnapshotCallback): void;
    getTransaction(): Promise<[Transaction]>;
    getTransaction(callback: GetTransactionCallback): void;
    makePooledRequest_(config: RequestConfig): Promise<Session>;
    makePooledRequest_(config: RequestConfig, callback: PoolRequestCallback): void;
    /**
     * Make an API request as a stream, first assuring an active session is used.
     *
     * @private
     *
     * @param {object} config Request config
     * @returns {Stream}
     */
    makePooledStreamingRequest_(config: RequestConfig): Readable;
    run(query: string | ExecuteSqlRequest): Promise<RunResponse>;
    run(query: string | ExecuteSqlRequest, options?: TimestampBounds): Promise<RunResponse>;
    run(query: string | ExecuteSqlRequest, callback: RunCallback): void;
    run(query: string | ExecuteSqlRequest, options: TimestampBounds, callback: RunCallback): void;
    runPartitionedUpdate(query: string | ExecuteSqlRequest): Promise<[number]>;
    runPartitionedUpdate(query: string | ExecuteSqlRequest, callback?: RunUpdateCallback): void;
    /**
     * Create a readable object stream to receive resulting rows from a SQL
     * statement.
     *
     * Wrapper around {@link v1.SpannerClient#executeStreamingSql}.
     *
     * @see {@link v1.SpannerClient#executeStreamingSql}
     * @see [Query Syntax](https://cloud.google.com/spanner/docs/query-syntax)
     * @see [ExecuteSql API Documentation](https://cloud.google.com/spanner/docs/reference/rpc/google.spanner.v1#google.spanner.v1.Spanner.ExecuteSql)
     *
     * @fires PartialResultStream#response
     *
     * @param {string|ExecuteSqlRequest} query A SQL query or
     *     {@link ExecuteSqlRequest} object.
     * @param {TimestampBounds} [options] Snapshot timestamp bounds.
     * @returns {ReadableStream} A readable stream that emits rows.
     *
     * @example
     * const {Spanner} = require('@google-cloud/spanner');
     * const spanner = new Spanner();
     *
     * const instance = spanner.instance('my-instance');
     * const database = instance.database('my-database');
     *
     * const query = 'SELECT * FROM Singers';
     *
     * database.runStream(query)
     *   .on('error', function(err) {})
     *   .on('data', function(row) {
     *     // row = [
     *     //   {
     *     //     name: 'SingerId',
     *     //     value: '1'
     *     //   },
     *     //   {
     *     //     name: 'Name',
     *     //     value: 'Eddie Wilson'
     *     //   }
     *     // ]
     *   // ]
     *   })
     *   .on('end', function() {
     *     // All results retrieved.
     *   });
     *
     * //-
     * // Rows are returned as an array of objects. Each object has a `name` and
     * // `value` property. To get a serialized object, call `toJSON()`.
     * //-
     * database.runStream(query)
     *   .on('error', function(err) {})
     *   .on('data', function(row) {
     *     // row.toJSON() = {
     *     //   SingerId: '1',
     *     //   Name: 'Eddie Wilson'
     *     // }
     *   })
     *   .on('end', function() {
     *     // All results retrieved.
     *   });
     *
     * //-
     * // Alternatively, set `query.json` to `true`, and this step will be performed
     * // automatically.
     * //-
     * query.json = true;
     *
     * database.runStream(query)
     *   .on('error', function(err) {})
     *   .on('data', function(row) {
     *     // row = {
     *     //   SingerId: '1',
     *     //   Name: 'Eddie Wilson'
     *     // }
     *   })
     *   .on('end', function() {
     *     // All results retrieved.
     *   });
     *
     * //-
     * // The SQL query string can contain parameter placeholders. A parameter
     * // placeholder consists of '@' followed by the parameter name.
     * //-
     * const query = {
     *   sql: 'SELECT * FROM Singers WHERE name = @name',
     *   params: {
     *     name: 'Eddie Wilson'
     *   }
     * };
     *
     * database.runStream(query)
     *   .on('error', function(err) {})
     *   .on('data', function(row) {})
     *   .on('end', function() {});
     *
     * //-
     * // If you need to enforce a specific param type, a types map can be provided.
     * // This is typically useful if your param value can be null.
     * //-
     * const query = {
     *   sql: 'SELECT * FROM Singers WHERE name = @name',
     *   params: {
     *     name: 'Eddie Wilson'
     *   },
     *   types: {
     *     name: 'string'
     *   }
     * };
     *
     * database.runStream(query)
     *   .on('error', function(err) {})
     *   .on('data', function(row) {})
     *   .on('end', function() {});
     *
     * //-
     * // If you anticipate many results, you can end a stream early to prevent
     * // unnecessary processing and API requests.
     * //-
     * database.runStream(query)
     *   .on('data', function(row) {
     *     this.end();
     *   });
     */
    runStream(query: string | ExecuteSqlRequest, options?: TimestampBounds): PartialResultStream;
    runTransaction(runFn: RunTransactionCallback): void;
    runTransaction(options: RunTransactionOptions, runFn: RunTransactionCallback): void;
    runTransactionAsync<T = {}>(runFn: AsyncRunTransactionCallback<T>): Promise<T>;
    runTransactionAsync<T = {}>(options: RunTransactionOptions, runFn: AsyncRunTransactionCallback<T>): Promise<T>;
    /**
     * Create a Session object.
     *
     * It is unlikely you will need to interact with sessions directly. By default,
     * sessions are created and utilized for maximum performance automatically.
     *
     * @param {string} [name] The name of the session. If not provided, it is
     *     assumed you are going to create it.
     * @returns {Session} A Session object.
     *
     * @example
     * var session = database.session('session-name');
     */
    session(name?: string): Session;
    /**
     * Get a reference to a Table object.
     *
     * @throws {Error} If a name is not provided.
     *
     * @param {string} name The name of the table.
     * @return {Table} A Table object.
     *
     * @example
     * const {Spanner} = require('@google-cloud/spanner');
     * const spanner = new Spanner();
     *
     * const instance = spanner.instance('my-instance');
     * const database = instance.database('my-database');
     *
     * const table = database.table('Singers');
     */
    table(name: string): Table;
    updateSchema(statements: Schema): Promise<UpdateSchemaResponse>;
    updateSchema(statements: Schema, callback: UpdateSchemaCallback): void;
    /**
     * Format the database name to include the instance name.
     *
     * @private
     *
     * @param {string} instanceName The formatted instance name.
     * @param {string} name The table name.
     * @returns {string}
     *
     * @example
     * Database.formatName_(
     *   'projects/grape-spaceship-123/instances/my-instance',
     *   'my-database'
     * );
     * // 'projects/grape-spaceship-123/instances/my-instance/tables/my-database'
     */
    static formatName_(instanceName: string, name: string): string;
}
/**
 * Reference to the {@link Database} class.
 * @name module:@google-cloud/spanner.Database
 * @see Database
 */
export { Database };
